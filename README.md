# notes---Kubernetes

1- Deployment vs ReplicaSet: Deployment provides higher-level abstractions and additional features such as rolling updates, rollbacks, and versioning of the application. ReplicaSet is a lower-level abstraction that provides basic scaling mechanisms, i.e., ensures that a specified number of Pod replicas are running at any given time. As a result, we are allowed to edit a limited number of fields in a Pod's definition with 'kubectl edit'. For other changes, we need to manually remove the existing Pod first before creating a new Pod (replace). However, in Deployments' definitions, we can modify those fields with `kubectl edit' since Deployment performs [rolling update](https://kubernetes.io/docs/tutorials/kubernetes-basics/update/update-intro/).

2- Specified "command" and "args" fields, for each container, override "ENTRYPOINT" and "CMD" of its image, respectively. When "command" is provided, Dockerfile "ENTRYPOINT" and "CMD" are both ignored. When "args" is only set, "CMD" in Dockerfile is replaced with "args". The first argument of "command" (or "ENTRYPOINT") must be an executable (We may need to update PATH env. variable to be able to run the executable). All arguments in "args" (or "CMD") will be appended to "command" (or "ENTRYPOINT"). Since providing long options is possible in both "--key=value" and "--key value" formats ([reference](https://unix.stackexchange.com/questions/573377/do-command-line-options-take-an-equals-sign-between-option-name-and-value), args/CMD can be written in both ways: '["--key=value"]' and '["--key". "value"]'

3- ConfigMap stores non-confidential data in key-value pairs. ConfigMap can be injected into Pods as **environment variables**, command-line arguments, or as configuration files in a **volume**.
ConfigMap accepts both single line property values and multi-line file-like values. When creating ConfigMap using "kubectl create ConfigMap", "--from-literal" option creates single line property values and "--from-file" creates multi-line file-like values. In the later case, a key will be created from the file's name with its content as the value. We can control multi-line values format through header as explained in [this link](https://yaml-multiline.info/). We can inject the entire ConfigMap data into a Pod as environment variable(s) (under Pod's "spec.containers[].envFrom" section) or volume(s) (under Pod's "spec.volumes" section). We can also inject only specific keys into a Pod as environment variables (under Pod's "spec.containers[].env" section) or volumes (using items under Pod's "spec.volumes" section).
  
4- Different types of Secret exist. "Opaque" is the default Secret type. "kubernetes.io/dockerconfigjson" type is used to store credentials for accessing a container image registry. To pull an image from registry using "kubernetes.io/dockerconfigjson" type secrets, in Pod definition we need to add "imagePullSecrets" field under "spec" section.

5- ServiceAccounts are used to authenticate to Kubernetes API server. Before v1.22, for every ServiceAccount a long-lived static token was created using Secrets. Then by setting "spec.serviceAccountName" inside Pod, Kubernetes mounted that specific ServiceAccount's token, instead of default ServiceAccount's token, as a volume inside the Pod. From v1.22, kubernetes gets short-lived automatically rotating (instead of long-lived static) tokens using the TokenRequest API (instead of Secret) and mounts it in Pod as a projected volume. These tokens are time and audiance bounded (their lifetime depends on the Pod rather than the ServiceAccount). From v1.24, Kubernetes no longer generates tokens automatically. Administrators are responsible for that, for instance by running "kubectl create token <service-account-name>". To prevent kubernetes from automatically injecting credentials (for a specified ServiceAccount or the default ServiceAccount) in the Pod, we must set "spec.automountServiceAccountToken" to false. Note that we can still get long-lived static tokens (similar to what we had before v1.22) using Secrets of type "kubernetes.io/service-account-token". Finally, by default, ServiceAccounts are granted default permissions. We must use RBAC to grant required permissions.

6, 7, 8, and 9 describe **Pod** scheduling onto nodes:

    6- ResourceQuotas limit aggregate resource consumption (limits.cpu, limits.memory, requests.cpu, requests.memory) per namespace. LimitRange is a policy to constrain the resource allocations (limits and requests) specified for each applicable object kind (such as Pod or PersistentVolumeClaim) in a namespace. For instance, if resource requests and limits are specified for a Pod they must be in the range [min, max] defined in LimitRange, and if not specified they will use default values defined in LimitRange. 

    7- Taints allow nodes to repel Pods. A Pod can be scheduled on a node only if it tolerates the taint, i.e., Tolerations applied to the Pod match the taints. Note that Tolerations allow scheduling but don't guarantee scheduling. In otherwise, tolerating a node's taints is the necessary condition to be able to schedule Pods on that node.

    8- With adding nodeSelector field in the Pod's definition and specifying node labels, a pod will **only** be scheduled onto the nodes that have all of the specified labels.

    9- Node affinity is conceptually similar to nodeSelector, allowing you to constrain which nodes your Pod can be scheduled on based on node labels. Compared to nodeSelector, affinity/anti-affinity is more expressive and provides more control over the selection logic. It also allows soft (preferred) rules. Similar to node taints, anti-affinity repel Pods from specific nodes.

10- In the absence of readinessProbe, a Pod is considered ready when all of its containers are created (**reference?**). With introducing a readinessProbe under .spec.containers[] for a container, application itself can decide on its readiness. An unready Pod does not receive traffic through Kubernetes Services. 
Liveness probes can be used to detect when to restart a container. For example, liveness probes can catch a deadlock, where an application is running and ready (receives traffic), but unable to make progress. Note that usually there is no need to consider application crash for liveness probe because upon main application (PID 1) crash the Pod is subjected to its restart policy (set by .spec.restartPolicy field).

11- Labels are key/value pairs that are attached to objects. Labels do not provide uniqueness. In general, we expect many objects to carry the same label(s). Via a label selector, the client/user can identify a set of objects. One usage scenario for label requirement is for Pods to specify node selection criteria (check Point 9). The API currently supports two types of selectors: equality-based and set-based ([more information](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/)). In kubectl commands, --selector option (or -l in short) allows filtering by label keys and values. --field-selector option also allows selecting Kubernetes objects based on the value of one or more resource fields. For example, metadata.namespace!=default or status.phase=Pending. It is worth mentionnig that, unlike --selector option, set-based selectors are not supported for --field-selector option.

---
Helpful 'kubectl' commands:
kubectl explain <resource-type>: to find out about api version for a resource type.
kubectl top <node or pod>: to see the resource consumption for nodes or pods.

---
To do:
https://kubernetes.io/docs/tasks/access-application-cluster/access-cluster/
After creating a container with kind, inside the container we have containerd client command line tool (ctl) and docker client is not provided. What is containerd?
core dump
